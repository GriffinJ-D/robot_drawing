#!/usr/bin/env python3

import time
from piper_sdk import C_PiperInterface_V2
import math


if __name__ == "__main__":
    piper = C_PiperInterface_V2("can_left_arm")
    piper.ConnectPort()

    #### START INIT ####
    piper.MotionCtrl_2(0x00, 0x00, 0, 0x00)  # ctrl_mode: standby
    time.sleep(1)
    piper.MotionCtrl_1(0x02, 0x00, 0x00)  # emergency_stop: resume, track_ctrl: disable, grag_teach_ctrl: disable
    time.sleep(1)
    piper.MotionCtrl_2(0x01, 0x00, 0, 0x00)
    # piper.MotionCtrl_2(0x01, 0x00, 100, 0x00)   # ctrl_mode: can command control mode, move_mode: move p, move_spd_rate_ctrl: 100, is_mit_mode: position-velocity mode
    time.sleep(1)

    timeout = 5
    start_time = time.time()
    while not piper.EnablePiper():  # Enable all joints
        time.sleep(0.01)
        if time.time() - start_time > timeout:
            print(f"TIMEOUT: Failed to enable joints!")
            break

    piper.MotionCtrl_2(0x01, 0x00, 10,
                       0x00)  # ctrl_mode: can command control mode, move_mode: move p, move_spd_rate_ctrl: 100, is_mit_mode: position-velocity mode
    time.sleep(1)
    piper.GripperCtrl(0, 1000, 0x01,
                      0)  # gripper_angle (unit 0.001mm), gripper_effort: 1N/m (0.001 N/m, range 0-5000 corresponds to 0-5 N/m), gripper_code: enable, set_zero: invalid
    time.sleep(1)
    #### END INIT ####

    factor = 1000

    CX = (300 + 200) / 2.0  # 225
    CY = (75 + (-25)) / 2.0  # 0
    R = (300 - 200) / 2.0  # 100 mm radius

    dtheta = math.radians(4)  # step per loop (~90 steps/rev)
    theta = 0.0  # starting angle

    count = -1
    try:
        while True:
            # compute the next point on the circle
            theta = (theta + dtheta) % (2 * math.pi)
            x = CX + R * math.cos(theta)
            y = CY + R * math.sin(theta)

            # keep your Z/orientation/gripper values
            position = [x, y, 130, 0, 170, 0, 0]

            # (unchanged) scale + send
            X = round(position[0] * factor)
            Y = round(position[1] * factor)
            Z = round(position[2] * factor)
            RX = round(position[3] * factor)
            RY = round(position[4] * factor)
            RZ = round(position[5] * factor)
            joint_6 = round(position[6] * factor)

            piper.EndPoseCtrl(X, Y, Z, RX, RY, RZ)
            piper.GripperCtrl(abs(joint_6), 1000, 0x01, 0)

            # smoother motion than 1.5s; start with ~30â€“50ms
            time.sleep(0.03)
    finally:
        print("\n\n---- Returning to the home position and exiting application in 2 secomds, goodbye ----\n\n")
        piper.EndPoseCtrl(57, 0, 215, 0, 90, 0, 0)
        time.sleep(1)
        piper.DisconnectPort()
